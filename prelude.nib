# Nib prelude: standard library and self-documentation system
#
# TODO: Library words from DESIGN still to implement
# [x] Stack: d(dup) n(nip) o(over) r(rot) W(dip) K(keep)
# [x] Logic: ‚àß(and) ‚à®(or) ¬¨(not/kernel) ‚ä§(true) ‚ä•(false)
# [x] Arithmetic: N(negate) A(abs) m(min) M(max) ‚åä ‚åà ‚Äî kernel
# [x] List: S(sum) P(product) L(last) R(range) Z(zip)
# [x] Map: ‚©ë(delete key) ‚Äî kernel
# [x] Clipboard: ‚úÇ(cut) ‚éò(copy/yank) p(paste)
# [x] Undo: ‚Ü∂ ‚Ü∑ (undo/redo via history register)
# [x] Error handling: ‚ö†(raise) ‚äò(clear)
# [x] File I/O: ‚éÜ(read) ‚á™(write) ‚Äî kernel
# [x] String: ‚çò ‚çô(codepoints) ‚äó(split) ‚çé(parse) ‚ç¥(repeat) J(join) ‚Äî kernel+lib
# [x] Comparison: ‚ãñ ‚ãó(lex cmp) ‚Äî kernel
# [x] Register: ‚çÄ(clear) ‚Äî kernel
# [x] Combinators: B(bi) ‚çâ(transpose)
# [x] Movement: ‚á§ ‚á•(line) ü†ï ü†ó(up/down) ‚Äî kernel
# --- still TODO (reader/syntax, needs careful design) ---
# [ ] Bracket list: [ ] (sentinel-based collector)
# [ ] Map literal: ‚ü® ‚ü© reader
# [ ] Grouping: ( ) reader
# [ ] Syntactic unit reader: ‚éï
# [ ] Insert mode: i ‚úé
#
# Bootstrap: define basic stack manipulation words first

{~}:d              # dup: duplicate top of stack
{‚áÖ‚äñ}:n             # nip: remove second item (swap drop)
{'t‚çÉ~'t‚çÇ‚áÖ}:o       # over: copy second item to top
{'t‚çÉ‚áÖ't‚çÇ‚áÖ}:r       # rot: rotate top 3 items (a b c -> b c a)

# Initialize documentation system
# __doc__ register holds a map of symbol names to descriptions

‚àÖ‚çö"__doc__"‚çÉ      # Create empty map in __doc__ register

# D word: document a symbol
# Stack: name desc -> (updates __doc__ register)
{oo"__doc__"‚çärr‚©ê"__doc__"‚çÇ‚äñ"__doc__"‚çÉ‚äñ‚äñ}:D

# Document bootstrap words
"d""duplicate TOS" D
"n""remove second item" D
"o""copy second item to top" D
"r""rotate top 3 (a b c -> b c a)" D

# Document kernel operators
"~""duplicate TOS" D
"‚áÖ""swap top 2" D
"‚äñ""drop TOS" D
"‚åó""selection index (0)" D

"+""add" D
"-""subtract" D
"*""multiply" D
"/""divide" D
"√ó""multiply" D
"√∑""divide" D
"|""modulo" D
"^""exponentiation" D

"=""equal" D
"‚â†""not equal" D
"<""less than" D
">""greater than" D
"‚â§""less or equal" D
"‚â•""greater or equal" D
"‚ãñ""lexicographic less" D
"‚ãó""lexicographic greater" D

"¬¨""logical not" D
"?""if (peek condition)" D
"!""if-not (peek condition)" D

"@""eval with new scope" D
"‚äõ""eval (no new scope)" D

"‚çÉ""push to register" D
"‚çÇ""pop from register" D
"‚çä""peek register" D
"‚çÅ""unpop register" D
"‚çÄ""clear register" D
"‚çà""register next" D
"‚çá""register prev" D

"‚ß∫""concat sequences" D
"‚Äñ""length" D
"‚åø""slice" D
"‚ä£""head" D
"‚ä¢""tail" D
"‚åΩ""reverse" D

"‚àÖ""empty list" D
"‚ôØ""sharpen (str->quot)" D
"‚ô≠""flatten (quot->str)" D
"‚çö""list to map" D
"‚çõ""map to list" D
"‚ß∞""is-number" D
"‚çï""format value" D
"‚çé""parse string to value" D
"‚äó""split string by delimiter" D

"‚äÇ""collect N items" D
"‚äÉ""spread list" D
"¬∑""lookup" D
"‚©ê""set key" D
"‚©ë""delete key" D
"‚äú""keep (filter)" D
"‚äù""reject" D
"‚çã""sort ascending" D
"‚çí""sort descending" D
"‚àä""member" D
"‚ç≥""index of" D

"‚ç£""repeat N times" D
"‚ç§""while (do-while)" D
"¬®""map over list" D
"/""fold/reduce" D

"‚éó""insert to buffer" D
"‚å´""delete back" D
"‚å¶""delete forward" D
"ü†î""move left" D
"ü†ñ""move right" D
"‚§í""buffer home" D
"‚§ì""buffer end" D
"‚á§""line start" D
"‚á•""line end" D
"ü†ï""move up" D
"ü†ó""move down" D
"‚äö""buffer text" D

"‚åä""floor" D
"‚åà""ceil" D

"‚çò""string to codepoints" D
"‚çô""codepoints to string" D

"‚éÜ""read file" D
"‚á™""write file (path content)" D
##"‚çû""read char from input" D
"‚èè""halt" D

# Additional library words

# Logic
{0‚â†‚áÖ0‚â†*}:‚àß         # and: (a b -> bool)
"‚àß""logical and" D

{0‚â†‚áÖ0‚â†+0>}:‚à®        # or: (a b -> bool)
"‚à®""logical or" D

1:‚ä§                 # true constant
"‚ä§""true (1)" D

0:‚ä•                 # false constant
"‚ä•""false (0)" D

# Arithmetic
{0‚áÖ-}:N             # negate: (n -> -n)
"N""negate number" D

{~0<{N}?‚äñ}:A        # abs: (n -> |n|)
"A""absolute value" D

{oo<{‚äñ}{‚áÖ‚äñ}?‚äñ}:m    # min: (a b -> min)
"m""minimum of two" D

{oo>{‚äñ}{‚áÖ‚äñ}?‚äñ}:M    # max: (a b -> max)
"M""maximum of two" D

# List operations
{0‚áÖ{+}/}:S          # sum: (list -> total)
"S""sum of list" D

{1‚áÖ{*}/}:P          # product: (list -> product)
"P""product of list" D

{‚åΩ‚ä£}:L              # last: (list -> last-item)
"L""last item in list" D

# Combinators
{‚áÖ't‚çÉ@'t‚çÇ}:W        # dip: (x q -> ... x) - apply q with x saved
"W""dip: run quot with TOS saved" D

{o‚áÖ@}:K             # keep: (x q -> ... x) - apply q to copy of x
"K""keep: run quot on copy of TOS" D

# Clipboard (uses __kill__ register)
{‚äö"__kill__"‚çÉ}:‚éò     # yank: buffer text -> __kill__ register
"‚éò""yank (copy) to kill register" D

{‚éò‚§í‚äö‚Äñ{‚å¶}‚áÖ‚ç£}:‚úÇ       # cut: yank then delete all buffer text
"‚úÇ""cut to kill register" D

{"__kill__"‚çä‚éó}:p      # paste: peek __kill__, insert to buffer
"p""paste from kill register" D

# Undo/redo (uses __history__ register)
{"__history__"‚çÇ‚äñ}:‚Ü∂   # undo: pop from history
"‚Ü∂""undo" D

{"__history__"‚çÅ}:‚Ü∑    # redo: unpop history
"‚Ü∑""redo" D

# Error handling (uses __errors__ register)
{"__errors__"‚çÉ}:‚ö†     # raise: push TOS to errors
"‚ö†""raise error" D

{"__errors__"‚çÇ‚äñ}:‚äò    # clear: pop and discard one error
"‚äò""clear error" D

# Range: n -> [0, 1, ..., n-1]
# repeat n times: each time push counter, wrap, append to acc
{:n 0'i‚çÉ ‚àÖ
 {'i‚çä1‚äÇ‚ß∫ 'i‚çÇ1+'i‚çÉ}   # append [i], inc i
 n‚ç£                    # repeat n times
 'i‚çÇ‚äñ                  # clean up counter reg
}:R
"R""range (n -> [0..n-1])" D

# Transpose: list of lists -> transposed list of lists
# [[1,2],[3,4]] -> [[1,3],[2,4]]
{:l l0¬∑‚ÄñR{:i l{i¬∑}¬®}¬®}:‚çâ
"‚çâ""transpose list of lists" D

# bi: apply two quotations to same value (x {p} {q} -> p(x) q(x))
{:q :p ~p‚áÖq}:B
"B""bi: apply two quots to same value" D

# Zip: pair elements from two lists ([a] [b] -> [[a0 b0] [a1 b1] ...])
{:b :a a‚ÄñR{:i a i¬∑ b i¬∑ 2‚äÇ}¬®}:Z
"Z""zip two lists" D

# Flatten list of strings into one string
{""{‚ß∫}/}:J
"J""join list of strings" D

# String repeat: "s" n -> "sss..."
{:n :s ""{s‚ß∫}n‚ç£}:‚ç¥
"‚ç¥""repeat string n times" D
