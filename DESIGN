# Nib
#
# Editor inspired by Kakoune with programming model inspired by TECO.
# Idea: Terse languages like APL prove TECO model can be a "real" programming language.
# Exact 1-1 correspondence between scripts and interactive usage.

# ============================================================================
# TYPES
# ============================================================================

# String   - Immutable text. Literals like "hello" create strings.
#            Self-quoting: eval is a no-op (pushes itself).
# Quotation - Code block. Literals like {code} create quotations.
#            NOT self-quoting: eval executes the code.
#            Quotations are strings tagged as code â€” same content, different eval behavior.
# Buffer   - Mutable text with marks, selections, history, scope.
#            Buffers are created explicitly (opening files, etc.), not from literals.
# Number   - Formatted string that remembers its representation.
#            Arithmetic coerces; 42 stays "42" not "42.0" when written back.
# Mark     - Logical position in a buffer (buffer-id, anchor).
#            Stays valid through edits (anchored to text identity, not offset).
# List     - Ordered collection. Clojure-style persistent vector:
#            O(log32 n) index/append, structural sharing for undo efficiency.
# Map      - Distinct type. Ordered key-value pairs: âŸ¨"a" 1 "b" 2âŸ©.
#            Â· does keyed lookup on maps, positional index on lists.
#
# Note: Symbols removed. Use strings or unique strings for sentinels.

# ============================================================================
# SYNTAX
# ============================================================================

# Commands are single characters.
# 'x        â†’ push single-char string "x"
# "asdf"    â†’ push string
# {code}    â†’ push quotation (code for later execution)
#              Nesting: {{x}} is a quotation containing a quotation.
# (code)    â†’ grouping: execute code with fresh stack, push results to outer stack
#              Like parens in other languages â€” isolation, not deferral.
# âŸ¨k v ...âŸ© â†’ push map (ordered pairs)
# 123       â†’ push number
# 123.45    â†’ push number
#
# ALL delimiters (' " { } ( ) âŸ¨ âŸ© [ ]) are library-defined reader functions
# using input lookahead (â). The kernel only provides construction primitives
# (âˆ…, âˆ…â‚›, âŠ›â‚›, digits, â§º, etc.). Syntax IS the library.
#
# Numbers: Digits 0-9 are kernel primitives that push their value.
# Multi-digit accumulation is a library reader: first digit pushes fresh,
# subsequent digits do TOS Ã— 10 + digit, non-digit breaks the sequence.
#
# ' is library-defined as {â} â€” read next char, push as string.
# Since strings are self-quoting, â alone does the same thing.
#
# Terminology (Forth-style):
#   word      = named code, defined with :
#   quotation = anonymous code block {...}
#
# CRITICAL: There are no multi-character tokens. Spaces are ignored.
# The input stream is processed one character at a time.
# A bare char like g means: look up 'g' in scope, eval what you find.
# So g is exactly equivalent to 'g @.
#
# Self-quoting: Numbers, strings, lists, maps evaluate as no-ops (push themselves).
# Quotations evaluate as code.
#   "hello" :g             # bind string to 'g' in block scope
#   g                      # â†’ "hello" (lookup g, eval â†’ string is self-quoting)
#   {â¤’} :g                 # bind quotation to 'g'
#   g                      # â†’ goes to top of buffer (lookup g, eval â†’ quotation executes)
#
# Multi-character names require quoting at BOTH ends:
#   "hello" "__scope__" "greeting" _ â©     # store under multi-char key
#   "__scope__" "greeting" Â· @             # retrieve by multi-char key

# ============================================================================
# LIST CONSTRUCTION
# ============================================================================

# Three syntaxes, different ergonomics:

'h 'j 'k 'l 4 âŠ‚       # count-based: collect top 4 items into list
[ 'h 'j 'k 'l ]       # bracketed: [ pushes sentinel symbol, ] collects to list
# 'h 'j 'k 'l ####    # APL-style: auto-wrap (syntax TBD)

# ============================================================================
# MAPS (ORDERED PAIRS)
# ============================================================================

# Maps are a distinct type: ordered key-value pairs.
# Not lists of pairs â€” a separate type with its own semantics.

# Construction:
âŸ¨ "name" "Alice" "age" 30 âŸ©     # literal map: nameâ†’Alice, ageâ†’30

# Unified lookup with Â·
list 0 Â·                        # list index: get element 0
map "key" Â·                     # map lookup: find pair with key, return value

# Other ops:
map "key" value â©               # set/update key
map 'âŠ£ Â¨                        # keys
map 'âŠ¢ Â¨                        # values
map "key" âˆˆ                     # has key? (sets flag)
map "key" â©‘                     # delete key

# Nested access:
data "users" Â· 0 Â· "name" Â·     # data.users[0].name

# Maps make JSON natural:
json-str â                      # parse JSON string â†’ map/list structure
data â•                          # format map/list â†’ JSON string

# Modules as maps:
âŸ¨
  "trim" { ğœ±ª / +$/ âŒ• ğœ±ª âŒ« }
  "wrap" { :t "\"" t "\"" â§º â§º }
âŸ© :s

# Usage:
s "trim" Â· @                    # get function from module, execute

# ============================================================================
# SCOPES & LOOKUP
# ============================================================================

# Scope chain:
#   block â†’ mark â†’ buffer â†’ global
#
# Block scope is created fresh by eval (@). Local bindings live here.
# Lookup searches upward.

# Local binding (: is a reader that consumes next char):
:x                   # bind TOS to "x" in block scope

# Explicit scope access (scopes are maps):
"__buffer__" "foo" value â©    # set in buffer scope
"__global__" "foo" value â©    # set in global scope
"__buffer__" "foo" Â·          # get from buffer scope

# Lookup:
f                    # search block â†’ mark â†’ buffer â†’ global, then eval

# Module namespacing: use maps
âŸ¨ "trim" {...} "wrap" {...} âŸ© :m
m "trim" Â· @

# ============================================================================
# REGISTERS (TREES, NOT STACKS)
# ============================================================================

# Registers are trees with a cursor, not simple stacks.
# Popped values aren't lost â€” they become branches.
# Pushing after popping creates a sibling branch.

"text" 'a âƒ          # push to register a (create child, move to it)
'a â‚                 # pop from register a (move to parent, child becomes branch)
'a â                 # unpop (move back to last child / restore branch)
'a âˆ                 # switch to next sibling branch
'a â‡                 # switch to prev sibling branch
'a âŠ                 # peek (no movement)

# Example (register 'a):
#   1 'a âƒ  2 'a âƒ  3 'a âƒ   â†’  [1, 2, 3]
#   'a â‚                     â†’  [1, 2]     (3 is saved as branch)
#   4 'a âƒ                   â†’  [1, 2, 4]  (4 is sibling to 3)
#   'a â‚                     â†’  [1, 2]
#   'a â                     â†’  [1, 2, 4]  (back to last branch)
#   'a âˆ                     â†’  [1, 2, 3]  (switch to other branch)

# The main stack is the unnamed/default register.
# Kill-ring behavior falls out naturally (it's just a register tree).

# ============================================================================
# KEYBINDINGS
# ============================================================================

# ğŸ—º defines key mappings (affects UI interpretation)

'h 'ğŸ ” ğŸ—º              # h â†’ move left
'j 'ğŸ — ğŸ—º              # j â†’ move down
'k 'ğŸ • ğŸ—º              # k â†’ move up
'l 'ğŸ – ğŸ—º              # l â†’ move right

'% 'ğœ±ª ğŸ—º              # % â†’ select all
's 'âŒ¹ ğŸ—º              # s â†’ split selection by regex

# Keybindings stored in a mode map (normal, insert, etc.)

# ============================================================================
# SELECTIONS & RANGES
# ============================================================================

# Core editing model (Kakoune-inspired):
#   Mark      = anchored position in a buffer (stays valid through edits)
#   Range     = [start-mark, end-mark] â€” a span of text
#   Selection = list of ranges â€” the "current selection" for editing ops
#
# Selections are values, not hidden state. Editing ops take selection as input.
# Marks are values too â€” no "set mark" global state.
#
# Selection index: âŒ— returns current selection's index (0-based).
# Useful for numbering, sequencing, or conditional logic per-selection.
#
# Scope inheritance: When narrowing/splitting a selection, children inherit
# the parent's scope. This enables patterns like select-csv where row/col
# metadata flows down to cell selections automatically.

# ============================================================================
# CONDITIONALS
# ============================================================================

# Unlike Kakoune, zero selections is valid.
# Zero selections = "false" â€” subsequent selection-based ops become no-ops.
# This enables conditional logic without explicit branching.

# Comparisons push 1 (true) or 0 (false) onto the stack.
# ? peeks condition and executes block if truthy; ! if falsy.
# Condition is preserved (pushed back) after exec, enabling chaining.
# Drop condition with âŠ– after a conditional chain.

'a 'b =              # string equality â†’ pushes 1 or 0
5 3 >                # numeric compare â†’ pushes 1 or 0

1 1 = {do-this} ? âŠ–             # if 1=1, execute block, drop condition
a b = {if-true} ? {if-false} ! âŠ–  # if-else pattern (condition preserved after each)
x {fallback} ! âŠ–                # unless pattern

# ============================================================================
# OVERLAYS
# ============================================================================

# Overlays are lists of marks associated with a buffer but not the current selection.
# Use cases: syntax highlighting, error markers, search results, bookmarks.
# Stored in buffer scope: buffer.overlays.errors, buffer.overlays.search, etc.
# Applying marks from wrong buffer â†’ empty selection (graceful failure).

# ============================================================================
# CODE EXECUTION
# ============================================================================

# Words are code bound to names. Quotations are anonymous code.
# No closures, no capture â€” just dynamic lookup.

# Defining words:
{â¤’} :g               # bind quotation to 'g' in local scope
g                    # â†’ goes to top (lookup g, find quotation, execute)

# Execution rules:
#   string     â†’ no-op, push self (self-quoting)
#   quotation  â†’ interpret as code, execute
#   number     â†’ no-op, push self (self-quoting)
#   list       â†’ no-op, push self
#   map        â†’ no-op, push self

# Strings are values; quotations are code:
"hello" :g           # bind string to 'g'
g                    # â†’ "hello" on stack (string is self-quoting)
{â¤’} :g               # bind quotation to 'g'
g                    # â†’ goes to top of buffer (quotation executes)

# Scope addressing:
#   :x                      local (block scope)
#   "__buffer__" "x" v â©    buffer scope (explicit)
#   "__global__" "x" v â©    global scope (explicit)

# Two eval variants:
#   @              eval in fresh block scope (standard)
#   "__eval__" @   eval in parent scope (library use, e.g., implementing :)

# Grouping:
#   (code)         execute immediately with fresh stack, push results to outer
#   (1 2 +)        â†’ 3 on outer stack
#   5 (1 2 +)      â†’ 5 3 (inner code can't touch the 5)

# ============================================================================
# INPUT STREAM
# ============================================================================

# "__input__" is a buffer containing the command stream.
# Everything executed is already captured there â€” no special recording needed.
#
# Read primitives (from __input__):
#   â        read next char (raw)
#   â•        read next syntactic unit (number, "string", {quotation}, (group), âŸ¨mapâŸ©, or single char)
#
# In interactive mode: â waits for keystroke, â• waits for complete syntactic unit.
# In script mode: â consumes next char, â• consumes next syntactic unit.
# Same semantics, different input source â€” 1-1 correspondence preserved.
#
# Macros:
#   Recording = mark start/end positions in __input__, copy that range
#   Playback = insert saved content into __input__ (it executes as if typed)
#   __input__ is a buffer, so normal buffer ops work on it.
#
# Minibuffer is just a buffer in the "__minibuffer__" register.
# Reader functions can update it procedurally for UI feedback.

# ============================================================================
# READER FUNCTIONS (library-defined)
# ============================================================================

# Reader functions are just functions that read from __input__.
# All delimiters (" { } âŸ¨ âŸ© [ ] etc.) are reader functions, not kernel ops.
#
#   {â} :'                               # char literal: read one char, push as string
#   { â• :c c c } :2                      # repeat: reads next unit, executes twice

# ============================================================================
# INSERT MODE
# ============================================================================

# Insert mode is just a reader function, not a special execution mode.
#
# Two variants with different terminators:
#   i    terminates on \0 (null)  â€” for interactive use & recorded macros
#   âœ    terminates on âœ          â€” for scripts (visible delimiter)
#
# Interactive: i enters insert mode, each keystroke inserts, <Esc> ends it.
# Recorded macro: captures literal \0, plays back correctly with i.
# Script: âœhello worldâœ
#
# Both call "__insert__" with different terminator param.
# Implementation sketch (library space):
#   { :t { â :c  c t â‰  { c â— } ? } â¤ }  "__scope__" "__insert__" _ â©
#   { '\0 "__scope__" "__insert__" Â· @ } :i
#   { 'âœ "__scope__" "__insert__" Â· @ } :âœ
#
# No special "mode" machinery â€” just functions reading from input stream.

# ============================================================================
# UNDO MODEL
# ============================================================================

# Every buffer has an implicit .history register (a tree, like all registers).
# Edits push to the history. Undo/redo navigate the tree.
#
# Library definitions (not primitives):
#   { "__history__" â‚ } :â†¶     # undo = pop from buffer's history tree
#   { "__history__" â } :â†·     # redo = unpop (restore branch)
#   { "__history__" âŠ³ } :âŠ³     # switch to sibling branch (alt timeline)
#   { "__history__" âŠ² } :âŠ²     # switch to other sibling
#
# The tree structure gives us undo branches for free:
#   - Edit after undo creates sibling branch
#   - Navigate between branches with âŠ³/âŠ²
#   - Full undo tree like Emacs
#
# TOS preserved across undo (for carrying values across timelines):
#   {try} $ :r â†¶ r              # sandbox: do thing, grab result, undo, keep result
#
# "Undo buffer but not selection":
#   :s â†¶ s                      # save selection, undo, restore selection
#
# History is editable (it's a buffer):
#   "__history__" @ âœ           # edit history directly, changes propagate
#
# --- Undo Grouping ---
#
# Runtime primitives (with sentinel for safety):
#   "regname" sentinel âš‘        # checkpoint register with sentinel
#   "regname" sentinel âš        # squash since checkpoint (sentinel must match)
#
# Mismatched sentinel = no-op or error. Prevents dangling checkpoint bugs.
#
# Library wrapper (user-facing):
#   {expr} $                    # execute as single undo unit (generates sentinel internally)
#
# Users just write {block} $ â€” grouping internals are hidden.
# Elaborate undo features (descriptions, annotations) are addon libraries.

# ============================================================================
# ERRORS
# ============================================================================

# Errors push to the __errors__ register (a stack like any other).
# The error stack is exposed to the UI for visibility.
# Scripts can inspect/clear errors programmatically.

# ============================================================================
# OPERATOR SYMBOLS (REFERENCE)
# ============================================================================

# --- Movement ---
# ğŸ ” ğŸ — ğŸ • ğŸ –   left/down/up/right (char)
# â‡¤ â‡¥        beginning/end of line
# â¤’ â¤“        top/bottom of buffer
# â‡ â‡Ÿ        page up/down
# â® â­        word backward/forward
# â‡  â‡¢        prev/next match

# --- Selection ---
# ğœ±ª          select all
# âŒ¹          split selection by regex
# âŠ âŠ        select inner/outer (textobjects)
# â—‡ â—†        expand/shrink selection
# â§ â§        select to prev/next match
# âŠ† âŠ‡        select inside/around pair

# --- Stack ---
# âŠ‚          collect N items to list
# âŠƒ          spread list to stack
# â‡…          swap top two
# âŠ–          drop top
# âŠ›          dup top
# @          lookup & eval (fresh block scope)
# :          local bind (reader: consumes next char as name)
# âŒ—          current selection index
# âŠ•          TBD (nice symbol, needs a home)

# --- Registers (trees) ---
# âƒ          push (create child, move to it)
# â‚          pop (move to parent, child becomes branch)
# â          unpop (move to last child / restore branch)
# âˆ          next sibling branch
# â‡          prev sibling branch
# âŠ          peek (no movement)

# --- Arithmetic ---
# + - Ã— Ã·    basic math (or * /)
# âŒŠ âŒˆ        floor/ceil
# |          absolute value / modulo
# ^          exponent

# --- Comparison ---
# = â‰         equal / not equal
# < > â‰¤ â‰¥    numeric comparisons
# â‰¡ â‰¢        deep equal / not deep equal

# --- Logic ---
# âˆ§ âˆ¨ Â¬      and / or / not
# âŠ¤ âŠ¥        true / false literals

# --- Conditionals/Control ---
# ?          peek condition, execute if truthy (condition preserved)
# !          peek condition, execute if falsy  (condition preserved)
# â£          power: repeat N times
# â¤          while: do-while, body pushes condition, loop pops and checks
# âš           raise error (push to __errors__)
# âŠ˜          clear errors

# --- Text Editing ---
# âŒ« âŒ¦        delete backward/forward
# â€          toggle insert/replace mode
# â          insert newline
# â‡¥ â‡¤        indent/dedent

# --- Clipboard/Kill ---
# âœ‚          cut (delete + yank to "_" register)
# â˜          copy (yank to "_" register)
# â—          paste (from "_" register)
#            "_" is a tree register, so cycling through history works.

# --- Search ---
# âŒ•          search forward (regex)
# âŒ–          search backward (regex)
#
# --- Filtering (predicate-based) ---
# âŠœ          keep selections where {pred} returns true
# âŠ          reject selections where {pred} returns true
#            For regex filtering, use: /pat/ âŒ• ğœ±ª

# --- Undo/History (library-defined, built on register trees) ---
# â†¶          undo (pop buffer's history tree)
# â†·          redo (unpop / restore branch)
# âŠ³ âŠ²        switch undo branches (sibling navigation)
#
# --- Undo Grouping ---
# âš‘          checkpoint (runtime: "regname" sentinel âš‘)
# âš          squash (runtime: "regname" sentinel âš)
# $          group block as single undo unit (library: {expr} $)

# --- Buffer/File ---
# âŠ          new buffer
# âŠ           close buffer
# âŠ¡          switch buffer
# â          save
# â†          open file

# --- Selections ---
# (Selections are lists of ranges. Ranges are [start-mark, end-mark].
#  No "current mark" concept â€” marks are values, not global state.)

# --- Modes ---
# i          insert mode, \0 terminator (interactive, recorded macros)
# âœ ... âœ    insert mode, âœ terminator (scripts)
# â—«          visual/select mode
# (no explicit "normal mode" â€” it's just the default execution state)

# --- String/Buffer ---
# â§º          concat / append
# âŠ—          split by delimiter
# â€–          length
# âŒ¿          slice
# â‰          transpose
# â‹ â’        sort asc/desc

# --- List ---
# âŠ£ âŠ¢        head / tail (first / rest)
# âŠ² âŠ³        cons / snoc (prepend / append)
# âŒ½          reverse
# â â•        parse / format (stringâ†”value, including JSON)
# âˆŠ          member of
# â³          index of
# â´          reshape / dimensions

# --- Map/List Lookup ---
# Â·          get (list N Â· OR map key Â·) â€” unified lookup
# â©          set (map key value â©)
# â©‘          delete key (map key â©‘)
# ('âŠ£ Â¨ = keys, 'âŠ¢ Â¨ = values)

# --- Input Stream ---
# â          read next char (raw)
# â•          read next syntactic unit (number, string, block, map, or char)

# --- Misc ---
# ğŸ—º          define keybinding
# âˆ…          empty/null
# â‹¯          repeat last
# âŸ³          replay macro
# âŠ™          apply / call
# Â¨          each (map)
# âŒ˜          TBD (nice symbol, needs a home)

# ============================================================================
# MENU MACROS
# ============================================================================

# "Menu" macros look ahead one char and dispatch via map lookup.
# Useful for namespacing/modules:
#
#   âŸ¨ 'g {â¤’} 'd {"__goto_def__" @} 'e {â¤“} âŸ© :m
#   { â :c  m c Â· @ } :g            # read char, lookup in map, execute
#
# Usage:
#   gg  â†’  go to top      (g reads 'g', looks up in map, executes {â¤’})
#   gd  â†’  go to definition
#   ge  â†’  go to end
#
# This gives vim-style multi-key commands via library code.
# Modules export a map; menu macro does the dispatch.
#
# Aliases might need to be a language feature for efficiency (TBD).

# ============================================================================
# ASYNC / PIPES (SKETCH)
# ============================================================================

# For LSP, shell integration, etc., we need async I/O.
# Idea: A pipe/stream is a buffer where:
#   - Reading past loaded content blocks until data arrives
#   - Or: explicit async primitives (callbacks, promises, etc.)
#
# TBD: What's the right interface? Blocking buffer vs async primitives.

# ============================================================================
# CODE SAMPLES (EXPLORATORY)
# ============================================================================

# --- Interactive: select all TODOs, move to file ---
# "myfile.rs" â†  /TODO/ âŒ• ğœ±ª  âœ‚  "todos.txt" â†  â—

# --- Interactive: delete all lines containing "error" ---
# ğœ±ª /error/ âŠœ âŒ«

# --- Interactive: add "pub " before every "fn " ---
# /fn / âŒ• ğœ±ª â‡¤ âœpub âœ

# --- Script: wrap selection in quotes ---
# { â˜ :t  "\"" t "\"" â§º â§º  â— } :w

# --- Script: trim trailing whitespace ---
# { ğœ±ª / +$/ âŒ• ğœ±ª âŒ« } :t

# --- Menu macro: vim-style g namespace ---
# âŸ¨ 'g {â¤’} 'd {"__goto_def__" @} 'e {â¤“} âŸ© :m
# { â :c  m c Â· @ } :g            # read char, lookup in map, execute

# ============================================================================
# OBSERVATIONS FROM CODE SAMPLES
# ============================================================================

# Things that work well:
#   - Menu macro pattern with maps for namespacing/modules
#   - Select-then-act Kakoune style is concise
#   - Selections as implicit iteration (ops apply to all)
#   - Â¨ only needed when per-selection logic varies
#   - âŒ— (selection index) enables numbering, sequencing
#   - :x for local binding is visually clear
#
# Patterns:
#   - "Select, transform, paste": â˜ â†’ manipulate "__kill__" â†’ â—
#   - "Filter selections": {pred} âŠœ or {pred} âŠ
#   - "Structured data": library words like select-csv set scope metadata
#
# Gaps still present:
#   - String interpolation syntax (see sketch above)
#   - Regex capture groups (âŠ™N after match?)
#   - Case conversion (âŒƒ âŒ„ for upper/lower?)


# ============================================================================
# ALIGNMENT (LIBRARY-DEFINED)
# ============================================================================

# â«¼ (or similar) â€” align selections on a pattern
# Library-defined but important enough for a symbol:
#
#   /=/ â«¼              # align all = signs in selection
#
# Implementation finds max column position, pads each line.

# ============================================================================
# KERNEL vs LIBRARY
# ============================================================================

# KERNEL â€” must be implemented in host language (irreducible primitives)
#
# Format: symbol   stack-effect   [effects]
#
# Type aliases:
#   "  string       1  number       âŸ¨  map        [  list
#   {  quotation    !  mark         _  any        *  variadic
#   a-z  generic (only when same var repeated, else use _)
#
# Effects: [b] buffer, [s] sel, [r] reg, [i] input, [io] file

# Registers (tree structure) â€” stack is "__stack__", scope is "__scope__"
#   âƒ              _ " â†’           [r]      # push to register
#   â‚              " â†’ _           [r]      # pop (empty register â†’ falsey/nil)
#   â              " â†’             [r]      # unpop (restore last popped branch)
#   â€              " â†’             [r]      # clear (inverse of unpop, prunes branch)
#   âˆ              " â†’             [r]      # next sibling branch
#   â‡              " â†’             [r]      # prev sibling branch
#   âŠ              " â†’ _                    # peek (no movement)
# Eval â€” unscoped (uses __scope__ directly); @ in library wraps with fresh scope
#   âŠ›              _ â†’ *           [*]      # eval: executes quotation, no-op on string/number/list/map

# Conditionals â€” peek condition from stack, exec quotation, push condition back
#   ?              { cond â†’ cond *          # if truthy: exec quotation
#   !              { cond â†’ cond *          # if falsy: exec quotation
#   (typical pattern: a 1 = {f} ? {g} ! âŠ– â€” condition preserved, drop after chain)

# Comparison â€” = is deep equal; < > numeric; â‹– â‹— lexicographic
#   =              _ _ â†’ 1                  # deep equal (returns 1 or 0)
#   <              1 1 â†’ 1                  # numeric less
#   >              1 1 â†’ 1                  # numeric greater
#   â‹–              " " â†’ 1                  # lexicographic less
#   â‹—              " " â†’ 1                  # lexicographic greater

# Arithmetic
#   + - Ã— Ã·        1 1 â†’ 1                  # basic math
#   |              1 1 â†’ 1                  # modulo
#   ^              1 1 â†’ 1                  # exponent
#   âŒŠ âŒˆ            1 â†’ 1                    # floor / ceil

# Sequence ops â€” strings, lists, maps
#   â§º              _ _ â†’ _                  # concat (or map merge)
#   Â·              _ _ â†’ _                  # index (num) or key lookup (any type)
#   â€–              _ â†’ 1                    # length
#   âŒ¿              _ 1 1 â†’ _                # slice [start, end) â€” not for maps
#   â©              _ _ _ â†’                  # set at index/key (mutates)
#   â©‘              _ _ â†’                    # delete at index/key (mutates)

# Buffer â€” THE single buffer; no multiple buffers for now
#   â—              " â†’             [b]      # insert text at selections
#   âŒ«              â†’               [b]      # delete at selections
#   âŠ™              1 â†’ !                    # create mark at offset
#   âŠš              ! ! â†’ "                  # get text between marks
#   âŒ—              â†’ 1                      # current selection index (0-based)
#   âŠ•              â†’               [s]      # ensure selection exists (init if none)
#   â€–áµ‡             â†’ 1                      # buffer length (chars)

# Buffer movement (modify selection directly)
#   ğŸ ” ğŸ – ğŸ • ğŸ —        â†’               [s]      # move cursor left/right/up/down
#   â‡¤ â‡¥            â†’               [s]      # start/end of line
#   â¤’ â¤“            â†’               [s]      # top/bottom of buffer

# Buffer regex â€” returns marks, not strings
#   âŒ•              " â†’ [!]                  # find pattern â†’ list of mark pairs (ranges)
#   âŒ•Ìˆ              " " â†’           [b]      # replace pattern with string in buffer

# File I/O
#   â†              " â†’ "           [io]     # read file contents to string
#   â              " " â†’           [io]     # write string to file (path, content)

# Input
#   â              â†’ "             [i]      # read next char from __input__

# Undo â€” buffer changes auto-push to __history__; just use register ops
#   (undo = "__history__" â‚, redo = "__history__" â, branches = âˆ â‡)
#   âš‘              " â†’             [r]      # checkpoint: mark position for grouping
#   âš              â†’               [r]      # squash: collapse since last checkpoint

# Type
#   â§°              _ â†’ 1                    # is number? (returns 1 or 0)

# Construction â€” DS primitives
#   âˆ…              â†’ [                      # empty list (empty string = âˆ… â™)
#   â™¯              " â†’ {                    # sharpen: string â†’ quotation (tag as code)
#   â™­              { â†’ "                    # flatten: quotation â†’ string (strip code tag)
#   0-9            â†’ 1                      # push digit value (0 through 9)
#   â˜              " â†’ [1]                  # string â†’ list of codepoints
#   â™              [1] â†’ "                  # list of codepoints â†’ string
#   âš              [ â†’ âŸ¨                    # list of pairs â†’ map
#   â›              âŸ¨ â†’ [                    # map â†’ list of pairs

# ---

# LIBRARY â€” definable in terms of kernel
#
# Types: " string, 1 number, âŸ¨ map, [ list, { quotation, ! mark, _ any, * variadic

# --- Stack ops (stack = "__stack__" register) ---
#   âŠ› (ctrl+d)     a â†’ a a                     # dup: "__stack__" âŠ
#   âŠ– (ctrl+k)     _ â†’                         # drop: "__stack__" â‚ âŠ–  (pop and discard)
#   â‡… (ctrl+t)     a b â†’ b a                   # swap: via temp register

# --- Binding (scope = "__scope__" register, a map) ---
#   : (reader)     _ â†’                         # bind: reads name, sets in scope map
#   @              _ â†’ *           [*]         # scoped eval: push fresh scope, âŠ›, pop

# --- Char/token readers (all library-defined using â lookahead) ---
#   ' (')          â†’ "               [i]       # char literal: {â}
#   â•              â†’ _               [i]       # syntactic unit: parse from __input__
#   " { } âŸ¨ âŸ© [ ] ( )                          # all delimiter readers are library-defined

# --- Undo/redo (history = "__history__" register) ---
#   â†¶ (u)          â†’                 [b]       # undo: "__history__" â‚
#   â†· (ctrl+r)     â†’                 [b]       # redo: "__history__" â

# --- Clipboard (kill = "__kill__" register) ---
#   âœ‚ (x)          â†’                 [b r]     # cut: copy + delete
#   â˜ (y)          â†’ "               [r]       # yank: selection text â†’ __kill__
#   p (p)          â†’                 [b]       # paste: __kill__ âŠ â— (interactive: if stack empty, use kill)
#   P              â†’                 [b]       # paste before

# --- Comparison (derived) ---
#   â‰               _ _ â†’ 1                     # not equal: = 1 â‡… -
#   â‰¤              1 1 â†’ 1                     # lte: > 1 â‡… -
#   â‰¥              1 1 â†’ 1                     # gte: < 1 â‡… -

# --- Logic (operate on values, not hidden flag) ---
#   âˆ§              1 1 â†’ 1                     # and
#   âˆ¨              1 1 â†’ 1                     # or
#   Â¬              1 â†’ 1                       # not

# --- Iteration ---
#   â£              { 1 â†’ *                     # repeat N times
#   â¤              { â†’ *                       # while: repeat while TOS truthy
#   Â¨              { [ â†’ [                     # map: apply block to each element

# --- List/sequence construction ---
#   âŠ‚              * 1 â†’ [                     # collect top N items into list
#   âŠƒ              [ â†’ *                       # spread list items onto stack
#   [ ]            â†’ [               [r]       # bracketed: [ pushes sentinel, ] collects
#   âŠ£ âŠ¢            [ â†’ _  /  [ â†’ [             # head / tail
#   âŒ½              [ â†’ [                       # reverse
#   â‹ â’            [ â†’ [                       # sort asc / desc
#   âˆŠ              _ [ â†’ 1                     # member of (returns 1/0)
#   â³              _ [ â†’ 1                     # index of (-1 if not found)

# --- String ---
#   â              " â†’ _                       # parse JSON/literal â†’ value
#   â•              _ â†’ "                       # format value â†’ JSON/string
#   â‰              [ â†’ [                       # transpose (list of lists)

# --- Insert mode ---
#   i (i)          â†’                 [b i]     # insert until \0 (interactive)
#   âœ              â†’                 [b i]     # insert until âœ (scripts)
#   a o O          â†’                 [b i]     # append / open below / open above

# --- Movement ---
#   ğŸ ”ğŸ –ğŸ •ğŸ — (hjkl)    â†’                 [s]       # left/right/up/down
#   â¤’ â¤“ (gg/G)     â†’                 [s]       # top/bottom of buffer
#   â‡¤ â‡¥ (0/$)      â†’                 [s]       # start/end of line
#   â® â­ (b/w)      â†’                 [s]       # word backward/forward
#   â‡ â‡Ÿ (^b/^f)    â†’                 [s]       # page up/down

# --- Selection ---
#   ğœ±ª (%)          â†’                 [s]       # select all
#   âŒ¹ (s)          " â†’               [s]       # split by regex
#   â—‡ â—†            â†’                 [s]       # expand / shrink
#   âŠ âŠ            " â†’               [s]       # select inner / outer (textobject)

# --- Search (library uses kernel regex) ---
#   / (/)          " â†’               [s]       # search forward: split buffer by pattern
#   n N            â†’                 [s]       # next / prev match

# --- Filter ---
#   âŠœ              { â†’               [s]       # keep selections where block truthy
#   âŠ              { â†’               [s]       # reject selections where block truthy

# --- Buffer management (via registers) ---
#   âŠ              â†’ _                         # new buffer (push to __buffers__)
#   âŠ               â†’                 [r]       # close buffer
#   âŠ¡              " â†’               [b]       # switch to buffer by name

# --- Error handling ---
#   âš               " â†’               [r]       # raise: push to __errors__
#   âŠ˜              â†’                 [r]       # clear errors

# --- Undo grouping ---
#   $              { â†’ *             [r]       # execute as single undo unit

# --- Keybinding ---
#   ğŸ—º              " { â†’                       # bind key in mode map

# --- Misc ---
#   â‹¯ (.)          â†’ *               [*]       # repeat last command
#   âˆ…              â†’ [                         # empty list

# ============================================================================
# OPEN QUESTIONS
# ============================================================================

# - APL-style grouping operator syntax (####)
# - Aliases as language feature?
# - Async I/O model for LSP, pipes, etc.
# - String interpolation syntax
# - Regex capture group access (âŠ™0, âŠ™1, ... after match?)
# - Auto-coercion: numbers â†’ strings when writing to buffer
# - Find home for: âŒ˜ âŠ• (nice symbols without assignment)
# - Restricting â for static analysis (declarative reader table idea â€” shelved)
